# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'GeoContextQGISPlugin_processing_dialog_base.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import os

from PyQt5.QtWidgets import QDialog
from qgis.PyQt import uic
from qgis.PyQt.QtCore import QSettings
from qgis.core import QgsSettings, QgsMapLayer

from coreapi import Client

import subprocess

# Import the PyQt and QGIS libraries
# this import required to enable PyQt API v2
# do it before Qt imports

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'GeoContextQGISPlugin_processing_dialog_base.ui'))


class ProcessingDialog(QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(ProcessingDialog, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        QDialog.__init__(self, parent)
        self.setupUi(self)

        settings = QgsSettings()
        schema = settings.value('geocontext-qgis-plugin/schema', '', type=str)
        url = settings.value('geocontext-qgis-plugin/url', '', type=str)

        client = Client()
        document = client.get(schema)  # Retrieve the API schema

        self.lineSchema.setValue(schema)
        self.lineUrl.setValue(url)

        self.list_context = client.action(document=document, keys=["csr", "list"])  # Get the list of context layers
        self.list_collection = [{'key': 'global_climate_collection', 'name': 'Global climate collection'},
                                {'key': 'healthy_rivers_collection', 'name': 'Healthy rivers collection'},
                                {'key': 'healthy_rivers_spatial_collection', 'name': 'Healthy rivers spatial filters'},
                                {'key': 'hydrological_regions', 'name': 'Hydrological regions'},
                                {'key': 'ledet_collection', 'name': 'LEDET collection'},
                                {'key': 'sa_boundary_collection', 'name': 'South African boundary collection'},
                                {'key': 'sa_climate_collection', 'name': 'South African climate collection'},
                                {'key': 'sa_land_cover_land_use_collection', 'name': 'South African land use collection'},
                                {'key': 'sa_river_ecosystem_collection', 'name': 'South African river collection'},
                                {'key': 'sedac_collection', 'name': 'Socioeconomic data and application center collection'}]

        list_key_names = []
        for context in self.list_context:
            name = context['name']
            list_key_names.append(name)
        list_key_names = sorted(list_key_names)

        self.cbKey.addItems(list_key_names)
        self.lineEditFieldName.setText(self.cbKey.currentText().replace(' ', '_').replace(",", "") + "_value")

        self.cbRegistry.currentTextChanged.connect(self.registry_changed)
        self.cbKey.currentTextChanged.connect(self.key_changed)

    def find_name_info(self, search_name, registry):
        if registry == "Service":
            for context in self.list_context:
                current_name = context['name']
                if current_name == search_name:
                    return context
        elif registry == "Group":
            print("group")
        elif registry == "Collection":
            for collection in self.list_collection:
                current_name = collection['name']
                if current_name == search_name:
                    return collection
        return None

    def registry_changed(self):
        registry = self.cbRegistry.currentText()
        self.update_key_list(registry)

    def key_changed(self):
        registry = self.cbRegistry.currentText()

        if registry.lower() == 'service':
            self.lblFieldName.setText("Field name")
            self.lineEditFieldName.setText(self.cbKey.currentText().replace(' ', '_').replace(",", "") + "_value")
        elif registry.lower() == 'group':
            self.lblFieldName.setText("Field prefix")
            self.lineEditFieldName.setText(self.cbKey.currentText().replace(' ', '_').replace(",", "") + "_")
        elif registry.lower() == 'collection':
            self.lblFieldName.setText("Field prefix")
            self.lineEditFieldName.setText(self.cbKey.currentText().replace(' ', '_').replace(",", "") + "_")

    def update_key_list(self, registry_type="service"):
        num_of_items = self.cbKey.count()
        while num_of_items >= 0:  # Clears the combobox list
            self.cbKey.removeItem(num_of_items)
            num_of_items = num_of_items - 1

        if registry_type.lower() == "service":
            settings = QgsSettings()
            schema = settings.value('geocontext-qgis-plugin/schema', '', type=str)

            client = Client()
            document = client.get(schema)  # Retrieve the API schema

            self.list_context = client.action(document=document, keys=["csr", "list"])  # Get the list of context layers

            list_key_names = []
            for context in self.list_context:
                name = context['name']
                list_key_names.append(name)
            list_key_names = sorted(list_key_names)

            self.cbKey.addItems(list_key_names)
        elif registry_type.lower() == "group":  # UPDATE
            list_groups = []
        elif registry_type.lower() == "collection":
            list_key_names = []
            for collection in self.list_collection:
                name = collection['name']
                list_key_names.append(name)

            self.cbKey.addItems(list_key_names)

    def check_parameters_for_errors(self):
        input_points = self.get_input_layer()
        if input_points.type() == QgsMapLayer.VectorLayer:
            if not input_points.hasFeatures():
                print("ERROR: Input file is empty.")
                return True
            input_type = input_points.wkbType()
            if not (input_type == 1 or input_type == 4):
                print("ERROR: Vector type can only be point.")
                return True
        else:
            print("ERROR: Not a vector layer.")
            return True

        registry = self.get_registry()
        if not (registry == "Service" or registry == "Group" or registry == "Collection"):
            print("ERROR: Registry can only be 'Service', 'Group' or 'Collection'.")
            return True

        key = self.get_key()

        field_name = self.get_fieldname()
        field_name_test = field_name.replace(" ", "").replace("_", "")
        if len(field_name_test) > 0:
            if not field_name_test.isalnum():
                print("ERROR: Fieldname is not alphanumberic.")
                return True
        else:
            print("ERROR: Fieldname is empty.")
            return True

        output_file = self.get_output_points()
        output_dir = os.path.dirname(output_file)
        output_file_name = os.path.basename(output_file)
        if not os.path.isdir(output_dir):
            print("ERROR: Directory does not exist.")
            return True
        if not (output_file_name.endswith(".gpkg") or output_file_name.endswith(".shp")):
            print("ERROR: Format can only be geopackage (gpkg) or shapefile (shp).")
            return True

        return False

    def get_input_layer(self):
        input_points = self.cbInputPoints.currentLayer()

        return input_points

    def get_selected_option(self):
        selected_features = self.cbSelection.isChecked()

        return selected_features

    def get_registry(self):
        registry = self.cbRegistry.currentText()

        return registry

    def get_key(self):
        key = self.cbKey.currentText()

        return key

    def get_fieldname(self):
        field_name = self.lineEditFieldName.text()

        return field_name

    def get_output_points(self):
        output_layer = self.fwOutputPoints.filePath()

        return output_layer

    def get_layer_load_option(self):
        load_output_file = self.cbOpenResult.isChecked()

        return load_output_file
